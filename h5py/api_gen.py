import re
import warnings


class BadLineError(Exception):
  pass

class UnknownCodeError(Exception):
  pass


# The following files are used to talk to the HDF5 api:
#
# (1) hdf5.pxd:         HDF5 function signatures    (autogenerated)
# (2) hdf5_types.pxd:   HDF5 type definitions       (static)
# (3) defs.pxd:         HDF5 function proxy defs    (autogenerated)
# (4) defs.pyx:         HDF5 function proxies       (autogenerated)

#re.match('\s*(.*?)\s*(\w*)\s*\(([\w\s,*\[\]]*)\)','  unsinged int* asdg( sadgasd g,sdgasdg,)').groups()
#re.findall('(\w+)\s*(?:\[|,|$)', 'unsigned *majnum, unsigned *minnum, unsigned *relnus')
regexFunc  = re.compile('\s*(?P<ret>.*?)\s*(?P<func>\w*)\s*\((?P<sig>[\w\s,*\[\]]*)\)')
regexParam = re.compile('(?P<param>\w+)\s*(?:\[|,|$)')

class strTbl:
  preambleRaw="""\
from api_types_hdf5 cimport *
from api_types_ext cimport *

"""
  preambleDef="""\
from api_types_hdf5 cimport *
from api_types_ext cimport *

"""
  preambleImp="""\
from api_types_ext cimport *
from api_types_hdf5 cimport *

cimport _hdf5

from _errors cimport set_exception

include "_locks.pxi"

rlock = FastRLock()
"""

  tplRaw="  %(ret)s %(func)s(%(sig)s)\n"
  tplDef="cdef %(ret)s %(func)s(%(sig)s) except *\n"

  tplImp = """\
cdef %(ret)s %(func)s(%(sig)s) except *:
    cdef %(ret)s r
    with rlock:
        r = _hdf5.%(func)s(%(args)s)
        if r%(condition)s:
            if set_exception():
                return <%(ret)s>%(retval)s;
        return r

"""

  tplImpStub = """\
cdef %(ret)s %(fname)s(%(sig)s) except *:
    with rlock:
        return hdf5.%(fname)s(%(args)s)

"""


class FunctionCruncher(object):

  def __init__(self, stub=False):
    self.stub = stub

  def run(self):

    # Function definitions file
    self.fsAPIFunc = open('api_functions.txt','r')

    # Create output files
    filenames=('_hdf5.pxd','defs.pxd','defs.pyx')
    self.fsRaw = open(filenames[0],'w')
    self.fsDef = open(filenames[1],'w')
    self.fsImp = open(filenames[2],'w')

    self.fsRaw.write(strTbl.preambleRaw)
    self.fsDef.write(strTbl.preambleDef)
    self.fsImp.write(strTbl.preambleImp)

    for line in self.fsAPIFunc:
      if not line or line[0] == '#' or line[0] == '\n':
        continue
      try:
        self.handle_line(line)
      except BadLineError:
        warnings.warn("Skipped <<%s>>" % line)

    self.fsAPIFunc.close()
    self.fsRaw.close()
    self.fsDef.close()
    self.fsImp.close()
    print('files:'+', '.join(filenames)+' generated.')

  def handle_line(self, line):
    """ Parse a function definition line and output the correct code
    to each of the output files. """

    if line.startswith(' '):
      line = line.strip()
      if line.startswith('#'):
        return
      m = regexFunc.match(line)
      if m is None:
        raise BadLineError(
            "Signature for line <<%s>> did not match regexp" % line
            )
      dictFuncElem = m.groupdict()
      
      dictFuncElem['sig']=dictFuncElem['sig'].replace('const ', 'const_')
      dictFuncElem['sig']=dictFuncElem['sig'].replace('const_unsigned char', 'const_unsigned_char')
      dictFuncElem['sig']=dictFuncElem['sig'].replace('const_unsigned int', 'const_unsigned_int')
      dictFuncElem['sig']=dictFuncElem['sig'].replace('const_unsigned short', 'const_unsigned_short')
      dictFuncElem['sig']=dictFuncElem['sig'].replace('const_unsigned long', 'const_unsigned_long')
      dictFuncElem['sig']=dictFuncElem['sig'].replace('const_long long', 'const_long_long')

      print dictFuncElem
      args = regexParam.findall(dictFuncElem['sig'])
      if args is None:
        raise BadLineError("Can't understand function signature <<%s>>" % dictFuncElem['sig'])
      args = ", ".join(args)

      # Figure out what conditional to use for the error testing
      ret = dictFuncElem['ret']
      if '*' in ret or ret in ('H5T_conv_t',):
        condition = "==NULL"
        retval = "NULL"
      elif ret in ('int', 'herr_t', 'htri_t', 'hid_t','hssize_t','ssize_t') \
        or re.match(r'H5[A-Z]+_[a-zA-Z_]+_t',ret):
          condition = "<0"
          retval = "-1"
      elif ret in ('unsigned int','haddr_t','hsize_t','size_t'):
        condition = "==0"
        retval = 0
      else:
        raise UnknownCodeError("return type <<%s>> unknown" % self.ret)

      dictFuncElem.update({'condition': condition, 'retval': retval, 'args': args})

      if stub:
        (tplRaw,tplDef,tplImp)=(strTbl.tplRaw,strTbl.tplDef,strTbl.tplImpStub)
      else:
        (tplRaw,tplDef,tplImp)=(strTbl.tplRaw,strTbl.tplDef,strTbl.tplImp)            

      self.fsRaw.write(tplRaw%dictFuncElem)
      self.fsDef.write(tplDef%dictFuncElem)
      self.fsImp.write(tplImp%dictFuncElem)
    else:
      inc = line.split(':')[0]
      self.fsRaw.write('cdef extern from "%s.h":\n' % inc)

if __name__ == '__main__':

  import sys
  stub = True if 'stub' in sys.argv else False
  fc = FunctionCruncher(stub)
  fc.run()



